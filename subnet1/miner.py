# File: subnet1/miner.py
# Tri·ªÉn khai c·ª• th·ªÉ cho Miner trong Subnet 1 (Image Generation)

import time
import logging
import traceback
import requests
import binascii  # Th√™m import n·∫øu ch∆∞a c√≥ (d√π kh√¥ng d√πng tr·ª±c ti·∫øp ·ªü ƒë√¢y)
from typing import Optional
import base64
from io import BytesIO
import os
from fastapi.responses import JSONResponse
import uvicorn
from PIL import Image
import httpx
import random

# Import t·ª´ SDK Moderntensor
try:
    # TaskModel v√† ResultModel ƒë·ªãnh nghƒ©a c·∫•u tr√∫c d·ªØ li·ªáu API
    # BaseMiner cung c·∫•p khung c∆° b·∫£n cho server miner
    from moderntensor_aptos.mt_core.network.server import BaseMiner, TaskModel, ResultModel
except ImportError:
    logging.error(
        "Could not import BaseMiner, TaskModel, or ResultModel from moderntensor_aptos.mt_core.network.server. "
        "Make sure the moderntensor SDK is installed correctly."
    )

    # L·ªõp gi·∫£ ƒë·ªÉ tr√°nh l·ªói n·∫øu import th·∫•t b·∫°i
    class TaskModel:
        task_id: str = "dummy_task"
        description: Optional[str] = None
        deadline: Optional[str] = None
        priority: Optional[int] = None
        validator_endpoint: Optional[str] = None

    class ResultModel:
        pass

    class BaseMiner:
        def __init__(self, *args, **kwargs):
            self.validator_url = kwargs.get(
                "validator_url"
            )  # URL validator m·∫∑c ƒë·ªãnh (fallback)

        def process_task(self, task: TaskModel) -> dict:
            return {}

        def handle_task(self, task: TaskModel):
            pass  # Th√™m handle_task gi·∫£

        def run(self):
            pass  # Th√™m run gi·∫£


# Import t·ª´ c√°c module kh√°c trong subnet n√†y
try:
    # C√°c h√†m ƒë·ªÉ sinh ·∫£nh v√† chuy·ªÉn ƒë·ªïi sang base64
    from .models.image_generator import generate_image_from_prompt, image_to_base64
except ImportError:
    logging.error(
        "Could not import image generation functions from .models.image_generator."
    )

    # H√†m gi·∫£ ƒë·ªÉ code ch·∫°y ƒë∆∞·ª£c n·∫øu import l·ªói
    def generate_image_from_prompt(*args, **kwargs):
        return None

    def image_to_base64(*args, **kwargs):
        return None


# L·∫•y logger
logger = logging.getLogger(__name__)

# --- Constants/Config (C√≥ th·ªÉ chuy·ªÉn ra file config ri√™ng) ---
# Thay th·∫ø b·∫±ng model ID b·∫°n mu·ªën d√πng
DEFAULT_MODEL_ID = "segmind/tiny-sd"
# C√≥ th·ªÉ ƒë·ªçc t·ª´ env var n·∫øu mu·ªën linh ho·∫°t h∆°n
MODEL_ID = os.getenv("IMAGEGEN_MODEL_ID", DEFAULT_MODEL_ID)


# --- 1. Task Processing Logic ---
def generate_image(prompt: str, seed: int = 42) -> bytes:
    """
    Placeholder for actual image generation logic using a model.
    Simulates generation and returns dummy image bytes.
    """
    logger.info(f"üé® Simulating image generation for prompt: '{prompt[:50]}...'")
    # Simulate some processing time
    time.sleep(random.uniform(0.5, 2.0))
    # Create a dummy image representation (e.g., simple text as bytes)
    dummy_image_content = f"Image for '{prompt}' with seed {seed}".encode("utf-8")
    logger.info(
        f"üñºÔ∏è Simulated image generated (size: {len(dummy_image_content)} bytes)."
    )
    return dummy_image_content


class Subnet1Miner(BaseMiner):
    """
    Miner chuy√™n th·ª±c hi·ªán nhi·ªám v·ª• sinh ·∫£nh cho Subnet 1.
    K·∫ø th·ª´a BaseMiner t·ª´ SDK Moderntensor v√† t√πy ch·ªânh logic x·ª≠ l√Ω task.
    """

    def __init__(
        self,
        validator_url: str,  # URL Validator m·∫∑c ƒë·ªãnh ƒë·ªÉ g·ª≠i k·∫øt qu·∫£ (fallback)
        on_chain_uid_hex: str,  # UID hex on-chain *th·ª±c t·∫ø* c·ªßa miner n√†y
        host: str = "0.0.0.0",  # Host IP ƒë·ªÉ server miner l·∫Øng nghe
        port: int = 8000,  # C·ªïng server miner l·∫Øng nghe
        miner_id: str = "subnet1_miner_default",  # ID d·ªÖ ƒë·ªçc ƒë·ªÉ nh·∫≠n di·ªán/logging
        model_id: str = MODEL_ID,
    ):
        """
        Kh·ªüi t·∫°o Subnet1Miner.

        Args:
            validator_url: URL c·ªßa validator m·∫∑c ƒë·ªãnh (d√πng n·∫øu task kh√¥ng c√≥ validator_endpoint).
            on_chain_uid_hex: UID hex on-chain c·ªßa miner n√†y (d√πng trong payload k·∫øt qu·∫£).
            host: ƒê·ªãa ch·ªâ host server miner.
            port: C·ªïng server miner.
            miner_id: T√™n ƒë·ªãnh danh d·ªÖ ƒë·ªçc cho miner n√†y (d√πng cho logging).
            model_id: ID c·ªßa model sinh ·∫£nh (v√≠ d·ª•: t·ª´ Hugging Face).
        """
        # G·ªçi __init__ c·ªßa l·ªõp cha (BaseMiner)
        # Pass miner_uid to BaseMiner's __init__ as well
        super().__init__(
            validator_url=validator_url,
            host=host,
            port=port,
            miner_uid=on_chain_uid_hex,
        )

        # L∆∞u tr·ªØ c√°c th√¥ng tin c·∫•u h√¨nh
        self.miner_id_readable = miner_id or on_chain_uid_hex
        self.on_chain_uid_hex = (
            on_chain_uid_hex  # ƒê√£ ƒë∆∞·ª£c g√°n b·ªüi super() n·∫øu d√πng miner_uid
        )
        self.model_id = model_id

        # Ki·ªÉm tra ƒë·ªãnh d·∫°ng UID hex (t√πy ch·ªçn nh∆∞ng n√™n c√≥)
        try:
            bytes.fromhex(self.on_chain_uid_hex)
        except (ValueError, TypeError):
            logger.error(
                f"Invalid on_chain_uid_hex provided to Subnet1Miner: '{self.on_chain_uid_hex}'. It must be a valid hex string."
            )
            # C√≥ th·ªÉ raise l·ªói ·ªü ƒë√¢y ƒë·ªÉ d·ª´ng kh·ªüi t·∫°o n·∫øu UID sai
            # raise ValueError("Invalid on_chain_uid_hex format.")

        logger.info(
            f"‚ú® [bold]Subnet1Miner[/] initializing for ID: [cyan]'{self.miner_id_readable}'[/] (UID: [yellow]{self.on_chain_uid_hex[:10]}...[/])"
        )
        logger.info(f"   üëÇ Listening on: [bold blue]{self.host}:{self.port}[/]")
        logger.info(
            f"   ‚û°Ô∏è Validator Submit URL: [link={self.validator_url}]{self.validator_url}[/link]"
        )
        logger.info(f"   üß† Using Image Gen Model: [magenta]{self.model_id}[/]")

        # T·∫£i model AI (c√≥ th·ªÉ m·∫•t th·ªùi gian)
        self.pipe = self._load_model()

    def _load_model(self):
        """T·∫£i model sinh ·∫£nh (v√≠ d·ª•: Stable Diffusion)."""
        logger.info(
            f"‚è≥ [bold]Loading image generation model[/] ([magenta]{self.model_id}[/])... This may take a while."
        )
        start_load_time = time.time()
        try:
            # --- Logic t·∫£i model th·ª±c t·∫ø ---
            logger.debug("   Attempting to load model pipeline...")
            # pipe = StableDiffusionPipeline.from_pretrained(self.model_id)
            # # T·ªëi ∆∞u h√≥a n·∫øu c√≥ GPU
            # if torch.cuda.is_available():
            #     logger.info("   üöÄ CUDA detected. Moving model to GPU.")
            #     pipe = pipe.to("cuda")
            # elif torch.backends.mps.is_available(): # Cho Apple Silicon
            #     logger.info("   üçè MPS detected. Moving model to MPS.")
            #     pipe = pipe.to("mps")
            # else:
            #     logger.info("   üêå No GPU acceleration detected (CUDA/MPS). Running on CPU.")

            # >>> Thay b·∫±ng logic t·∫£i model c·ªßa b·∫°n <<<
            # Gi·∫£ l·∫≠p vi·ªác t·∫£i model
            time.sleep(2)
            pipe = "FAKE_MODEL_PIPELINE"  # Placeholder
            # --------------------------------
            load_duration = time.time() - start_load_time
            logger.info(
                f"‚úÖüß† [bold]Image generation model[/] ([magenta]{self.model_id}[/]) [bold green]loaded successfully[/] in {load_duration:.2f}s."
            )
            return pipe
        except Exception as e:
            load_duration = time.time() - start_load_time
            logger.exception(
                f"üí•‚ùå [bold red]Failed[/] to load image generation model '{self.model_id}' after {load_duration:.2f}s: {e}"
            )
            # C√≥ th·ªÉ raise l·ªói ho·∫∑c tho√°t n·∫øu kh√¥ng load ƒë∆∞·ª£c model
            raise RuntimeError(f"Could not load model: {self.model_id}") from e

    def process_task(self, task: TaskModel) -> dict:
        """
        Th·ª±c hi·ªán task v√† tr·∫£ v·ªÅ dictionary ch·ª©a chi ti·∫øt k·∫øt qu·∫£.
        Dict n√†y s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t v√†o tr∆∞·ªùng 'result_data' c·ªßa ResultModel.
        """
        # S·ª≠ d·ª•ng ID d·ªÖ ƒë·ªçc cho logging
        logger.info(
            f"‚õèÔ∏è [bold]Processing task[/] [yellow]{task.task_id}[/yellow] for miner '{self.miner_id_readable}'"
        )
        start_time = time.time()

        # L·∫•y prompt t·ª´ task.task_data (theo ƒë·ªãnh nghƒ©a TaskModel m·ªõi)
        prompt = task.description

        if not prompt:
            logger.warning(
                f"Task {task.task_id} received without a valid 'description' in task_data."
            )
            duration = time.time() - start_time
            return {
                "error": "No prompt provided in task_data.description",
                "processing_time_ms": int(duration * 1000),
            }

        logger.debug(f"Task {task.task_id} - Prompt: '{prompt}'")

        # --- Th·ª±c hi·ªán sinh ·∫£nh ---
        generated_image = None
        error_message = None
        image_base64_string = None
        generation_start_time = time.time()
        logger.info(
            f"   ‚è≥ [italic]Starting image generation...[/] (Task: {task.task_id}) "
        )
        try:
            generated_image = generate_image_from_prompt(prompt=prompt)
            generation_duration = time.time() - generation_start_time
            if generated_image:
                logger.info(
                    f"   ‚úÖüñºÔ∏è [italic]Image generated successfully[/] in {generation_duration:.2f}s. (Task: {task.task_id}) "
                )
            else:
                logger.warning(
                    f"   ‚ö†Ô∏è [italic]Image generation returned None[/] after {generation_duration:.2f}s. (Task: {task.task_id}) "
                )
        except Exception as e:
            generation_duration = time.time() - generation_start_time
            logger.exception(
                f"   üí• [italic red]Exception during image generation[/] after {generation_duration:.2f}s: {e} (Task: {task.task_id}) "
            )
            error_message = f"Generation Error: {type(e).__name__}"
            traceback.print_exc()

        total_duration = time.time() - start_time

        # --- X·ª≠ l√Ω k·∫øt qu·∫£ ---
        if error_message:
            logger.warning(
                f"   ‚ùå Task {task.task_id} failed with error: {error_message}"
            )
            return {
                "error_details": error_message,
                "processing_time_ms": int(total_duration * 1000),
            }

        if generated_image is None:
            logger.warning(f"   ‚ùå Task {task.task_id} failed: No image generated")
            return {
                "error_details": "No image generated",
                "processing_time_ms": int(total_duration * 1000),
            }

        # --- Chuy·ªÉn ƒë·ªïi sang base64 ---
        try:
            image_base64_string = image_to_base64(generated_image)
            if not image_base64_string:
                logger.warning(
                    f"   ‚ùå Task {task.task_id} failed: Could not convert image to base64"
                )
                return {
                    "error_details": "Could not convert image to base64",
                    "processing_time_ms": int(total_duration * 1000),
                }
        except Exception as e:
            logger.exception(f"   üí• Error converting image to base64: {e}")
            return {
                "error_details": f"Base64 conversion error: {type(e).__name__}",
                "processing_time_ms": int(total_duration * 1000),
            }

        # --- Tr·∫£ v·ªÅ k·∫øt qu·∫£ th√†nh c√¥ng ---
        logger.info(
            f"   ‚úÖ Task {task.task_id} completed successfully in {total_duration:.2f}s"
        )
        return {
            "output_description": image_base64_string,
            "processing_time_ms": int(total_duration * 1000),
            "miner_uid": self.on_chain_uid_hex,
            "model_id": self.model_id,
        }

    def handle_task(self, task: TaskModel):
        """
        X·ª≠ l√Ω task - g·ªçi process_task v√† g·ª≠i k·∫øt qu·∫£.
        """
        try:
            # Process the task
            result_data = self.process_task(task)

            # Create result model
            result = ResultModel(
                task_id=task.task_id,
                miner_uid=self.on_chain_uid_hex,
                result_data=result_data,
            )

            # Submit result to validator
            self.submit_result(result)

        except Exception as e:
            logger.exception(f"Error handling task {task.task_id}: {e}")
            # Create error result
            error_result = ResultModel(
                task_id=task.task_id,
                miner_uid=self.on_chain_uid_hex,
                result_data={
                    "error_details": f"Task handling error: {type(e).__name__}",
                    "processing_time_ms": 0,
                },
            )
            self.submit_result(error_result)

    def run(self):
        """
        Ch·∫°y server miner.
        """
        logger.info(f"üöÄ Starting Subnet1Miner server on {self.host}:{self.port}")
        try:
            # Call parent run method
            super().run()
        except Exception as e:
            logger.exception(f"Error running Subnet1Miner: {e}")
            raise

    def _encode_image(self, image: Image.Image) -> str:
        """
        Encode PIL Image to base64 string.
        """
        buffered = BytesIO()
        image.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode()
        return img_str
